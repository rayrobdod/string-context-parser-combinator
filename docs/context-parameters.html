<html><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><title>Context Parameters</title><link rel="shortcut icon" type="image/x-icon" href="../favicon.ico"></link><script type="text/javascript" src="../scripts/theme.js"></script><script type="text/javascript" src="../scripts/searchData.js" defer="true"></script><script type="text/javascript" src="../scripts/scastieConfiguration.js" defer="true"></script><link rel="stylesheet" href="../styles/nord-light.css"></link><link rel="stylesheet" href="../styles/scalastyle.css"></link><link rel="stylesheet" href="../styles/colors.css"></link><link rel="stylesheet" href="../styles/dotty-icons.css"></link><link rel="stylesheet" href="../styles/diagram.css"></link><link rel="stylesheet" href="../styles/filter-bar.css"></link><link rel="stylesheet" href="../styles/code-snippets.css"></link><link rel="stylesheet" href="../styles/searchbar.css"></link><link rel="stylesheet" href="../styles/social-links.css"></link><link rel="stylesheet" href="../styles/ux.css"></link><link rel="stylesheet" href="../styles/versions-dropdown.css"></link><link rel="stylesheet" href="../styles/fontawesome.css"></link><script type="text/javascript" src="../hljs/highlight.min.js" defer="true"></script><script type="text/javascript" src="../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../scripts/scaladoc-scalajs.js" defer="true"></script><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="https://scastie.scala-lang.org/embedded.js" defer="true"></script><script type="text/javascript" src="../scripts/data.js" defer="true"></script><script>var pathToRoot = "../";</script><script>var githubContributorsUrl = "https://api.github.com/repos/rayrobdod/string-context-parser-combinator";</script><script>var githubContributorsFilename = "/Base/src/docs/_docs/context-parameters.md";</script></head><body><div id="container"><div id="leftColumn"><div id="logo"><span><div class="projectName">string-context-parser-combinator</div></span><div id="version"><div class="versions-dropdown"><div onclick="dropdownHandler()" id="dropdown-button" class="dropdownbtn dropdownbtnactive"><div class="projectVersion">SNAPSHOT</div><div id="dropdown-content" class="dropdown-content"><input type="text" placeholder="Search..." id="dropdown-input" onkeyup="filterFunction()"></input></div></div></div></div><div class="socials"><a href="https://github.com/rayrobdod/string-context-parser-combinator"><span class="social-icon" data-icon-path="github-icon-white.png"></span></a></div></div><div id="paneSearch"></div><nav id="sideMenu2"><div class="ni expanded"><span class="nh expanded"><span class="ar"></span><a href="index.html"><span>string-context-parser-combinator</span></a></span><div class="ni expanded"><span class="nh selected"><a href="context-parameters.html"><span>Context Parameters</span></a></span></div><div class="ni "><span class="nh "><a href="getting-started.html"><span>Getting Started</span></a></span></div><div class="ni"><span class="nh "><span class="ar"></span><a href="../index.html"><span>API</span></a></span><div class="ni"><span class="nh "><span class="ar"></span><a href="../com/rayrobdod/stringContextParserCombinator.html"><span class="micon pa"></span><span>com.rayrobdod.stringContextParserCombinator</span></a></span><div class="ni "><span class="nh "><a href="../com/rayrobdod/stringContextParserCombinator/CodePoint.html"><span class="micon cl"></span><span>CodePoint</span></a></span></div><div class="ni "><span class="nh "><a href="../com/rayrobdod/stringContextParserCombinator/LiftFunction.html"><span class="micon tr"></span><span>LiftFunction</span></a></span></div><div class="ni "><span class="nh "><a href="../com/rayrobdod/stringContextParserCombinator/Parser.html"><span class="micon cl"></span><span>Parser</span></a></span></div><div class="ni "><span class="nh "><a href="../com/rayrobdod/stringContextParserCombinator/Parsers$.html"><span class="micon ob"></span><span>Parsers</span></a></span></div><div class="ni "><span class="nh "><a href="../com/rayrobdod/stringContextParserCombinator/RepeatStrategy.html"><span class="micon en"></span><span>RepeatStrategy</span></a></span></div></div><div class="ni"><span class="nh "><span class="ar"></span><a href="../com/rayrobdod/stringContextParserCombinator/typelevel.html"><span class="micon pa"></span><span>com.rayrobdod.stringContextParserCombinator.typelevel</span></a></span><div class="ni "><span class="nh "><a href="../com/rayrobdod/stringContextParserCombinator/typelevel/Eithered.html"><span class="micon tr"></span><span>Eithered</span></a></span></div><div class="ni "><span class="nh "><a href="../com/rayrobdod/stringContextParserCombinator/typelevel/Eithered$.html"><span class="micon ob"></span><span>Eithered</span></a></span></div><div class="ni "><span class="nh "><a href="../com/rayrobdod/stringContextParserCombinator/typelevel/Optionally.html"><span class="micon tr"></span><span>Optionally</span></a></span></div><div class="ni "><span class="nh "><a href="../com/rayrobdod/stringContextParserCombinator/typelevel/Optionally$.html"><span class="micon ob"></span><span>Optionally</span></a></span></div><div class="ni "><span class="nh "><a href="../com/rayrobdod/stringContextParserCombinator/typelevel/Repeated.html"><span class="micon tr"></span><span>Repeated</span></a></span></div><div class="ni "><span class="nh "><a href="../com/rayrobdod/stringContextParserCombinator/typelevel/Repeated$.html"><span class="micon ob"></span><span>Repeated</span></a></span></div><div class="ni "><span class="nh "><a href="../com/rayrobdod/stringContextParserCombinator/typelevel/Sequenced.html"><span class="micon tr"></span><span>Sequenced</span></a></span></div><div class="ni "><span class="nh "><a href="../com/rayrobdod/stringContextParserCombinator/typelevel/Sequenced$.html"><span class="micon ob"></span><span>Sequenced</span></a></span></div></div></div></div></nav></div><div id="main"><div id="leftToggler"><span class="icon-toggler"></span></div><div id="scaladoc-searchBar"></div><main id="main-content"><div class="breadcrumbs container"><a href="index.html">string-context-parser-combinator</a>/<a href="context-parameters.html">Context Parameters</a></div><div id="content"><html>
 <head></head>
 <body>
  <p>The Parser methods <code>andThen</code>, <code>orElse</code>, <code>repeat</code> and <code>optionally</code> each take a context parameter which describes how to combine the results of the aggregate parser's components. Each of these types reside in <a href="../com/rayrobdod/stringContextParserCombinator/typelevel.html">com.rayrobdod.stringContextParserCombinator.typelevel</a>. Each of these four types' companion object defines one low-priority given instance that accepts any type and produces an appropriate generic result. The companion object also defines additional instances for more specific types, usually to avoid sticking <code>scala.Unit</code> values in a collection, and maybe a few more for common use cases.</p> 
  <p>Defining custom instances of these types is supported. Making custom given instances can significantly reduce the number of explicit <code>map</code> calls required when writing a parser, however the usual advice with <a href="https://dotty.epfl.ch/docs/reference/contextual/givens.html">given instances</a> applies: keep types specific, or keep the scope of a given instance to the minimum viable to prevent given instances from becoming confusing.</p> 
  <section id="sequenced"> 
   <h1><a href="#sequenced" class="anchor"></a>Sequenced</h1> 
   <p>A <a href="../com/rayrobdod/stringContextParserCombinator/typelevel/Sequenced.html">Sequenced</a> describes how to combine two adjacent values into one value.</p> 
   <p>The fallback given sequenced places the two items in a tuple.</p> 
   <div class="snippet" scala-snippet="" runnable="">
    <div class="buttons"></div>
    <pre><code class="language-scala"><span id="1" class="hideable"><span class="tooltip-container"></span>import com.rayrobdod.stringContextParserCombinator.Parsers.Parser
</span><span id="2" class="hideable"><span class="tooltip-container"></span>class A {}
</span><span id="3" class="hideable"><span class="tooltip-container"></span>class B {}
</span><span id="4" class="hideable"><span class="tooltip-container"></span>val p1:Parser[A] = ???
</span><span id="5" class="hideable"><span class="tooltip-container"></span>val p2:Parser[B] = ???
</span><span id="6" class="hideable"><span class="tooltip-container"></span>
</span><span id="8" class=""><span class="tooltip-container"></span>((p1:Parser[A]) andThen (p2:Parser[B])):Parser[(A, B)]
</span></code></pre>
   </div> 
   <p>This library provides <code>Sequenced</code> values that handle the case where one value or the other is a <code>Unit</code>. When these are used, the unit value is dropped, leaving the other value in tact. If both values are <code>Unit</code>, then the result is <code>Unit</code>.</p> 
   <div class="snippet" scala-snippet="" runnable="">
    <div class="buttons"></div>
    <pre><code class="language-scala"><span id="1" class="hideable"><span class="tooltip-container"></span>import com.rayrobdod.stringContextParserCombinator.Parsers.Parser
</span><span id="2" class="hideable"><span class="tooltip-container"></span>class A {}
</span><span id="3" class="hideable"><span class="tooltip-container"></span>val u1:Parser[Unit] = ???
</span><span id="4" class="hideable"><span class="tooltip-container"></span>val u2:Parser[Unit] = ???
</span><span id="5" class="hideable"><span class="tooltip-container"></span>val p1:Parser[A] = ???
</span><span id="6" class="hideable"><span class="tooltip-container"></span>
</span><span id="8" class=""><span class="tooltip-container"></span>((u1:Parser[Unit]) andThen (u2:Parser[Unit])):Parser[Unit]
</span><span id="9" class=""><span class="tooltip-container"></span>((p1:Parser[A]   ) andThen (u2:Parser[Unit])):Parser[A]
</span><span id="10" class=""><span class="tooltip-container"></span>((u1:Parser[Unit]) andThen (p1:Parser[A]   )):Parser[A]
</span></code></pre>
   </div> 
   <p>The Sequenced interface consists of a single method which takes the two values as parameters and returns the resulting value.</p> 
   <p>Below is example of defining and using a custom Sequenced.</p> 
   <div class="snippet" scala-snippet="" runnable="">
    <div class="buttons"></div>
    <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>import java.time._
</span><span id="2" class="hideable"><span class="tooltip-container"></span>import com.rayrobdod.stringContextParserCombinator.Parsers._
</span><span id="3" class="hideable"><span class="tooltip-container"></span>import com.rayrobdod.stringContextParserCombinator.typelevel.Sequenced
</span><span id="4" class="hideable"><span class="tooltip-container"></span>val dateParser:Parser[LocalDate] = ???
</span><span id="5" class="hideable"><span class="tooltip-container"></span>val timeParser:Parser[LocalTime] = ???
</span><span id="6" class="hideable"><span class="tooltip-container"></span>
</span><span id="8" class=""><span class="tooltip-container"></span>given Sequenced[LocalDate, LocalTime, LocalDateTime] with {
</span><span id="9" class=""><span class="tooltip-container"></span>	def aggregate(date:LocalDate, time:LocalTime):LocalDateTime = date.atTime(time)
</span><span id="10" class=""><span class="tooltip-container"></span>}
</span><span id="11" class=""><span class="tooltip-container"></span>
</span><span id="12" class=""><span class="tooltip-container"></span>((dateParser:Parser[LocalDate]) andThen IsString("T") andThen (timeParser:Parser[LocalTime])):Parser[LocalDateTime]
</span></code></pre>
   </div>
  </section>
  <section id="eithered"> 
   <h1><a href="#eithered" class="anchor"></a>Eithered</h1> 
   <p>An <a href="../com/rayrobdod/stringContextParserCombinator/typelevel/Eithered.html">Eithered</a> describes how to treat a parser result that may be the result of one parser or the result of the other parser.</p> 
   <p>The fallback given Eithered creates a union type of the two component types. Since the union of a type with itself is equivalent to that same type, if this fallback Eithered is used for two parsers of the same type, then the result is a parser of that type.</p> 
   <div class="snippet" scala-snippet="" runnable="">
    <div class="buttons"></div>
    <pre><code class="language-scala"><span id="1" class="hideable"><span class="tooltip-container"></span>import com.rayrobdod.stringContextParserCombinator.Parsers.Parser
</span><span id="2" class="hideable"><span class="tooltip-container"></span>import com.rayrobdod.stringContextParserCombinator.typelevel.Eithered
</span><span id="3" class="hideable"><span class="tooltip-container"></span>class A {}
</span><span id="4" class="hideable"><span class="tooltip-container"></span>class B {}
</span><span id="5" class="hideable"><span class="tooltip-container"></span>val p1:Parser[A] = ???
</span><span id="6" class="hideable"><span class="tooltip-container"></span>val p2:Parser[B] = ???
</span><span id="7" class="hideable"><span class="tooltip-container"></span>val p3:Parser[A] = ???
</span><span id="8" class="hideable"><span class="tooltip-container"></span>
</span><span id="10" class=""><span class="tooltip-container"></span>((p1:Parser[A]) orElse (p2:Parser[B])):Parser[A | B]
</span><span id="11" class=""><span class="tooltip-container"></span>((p1:Parser[A]) orElse (p3:Parser[A])):Parser[A]
</span></code></pre>
   </div> 
   <p>This library provides given <code>Eithered</code> values that handle the case where one value or the other is a <code>Unit</code>. If both options are Parsers of Unit, the result is a Parser of Unit. Otherwise the Unit case is converted to a <code>scala.None</code>, and the non-unit case is wrapped in a <code>scala.Some</code>.</p> 
   <div class="snippet" scala-snippet="" runnable="">
    <div class="buttons"></div>
    <pre><code class="language-scala"><span id="1" class="hideable"><span class="tooltip-container"></span>import com.rayrobdod.stringContextParserCombinator.Parsers.Parser
</span><span id="2" class="hideable"><span class="tooltip-container"></span>class A {}
</span><span id="3" class="hideable"><span class="tooltip-container"></span>val p1:Parser[Unit] = ???
</span><span id="4" class="hideable"><span class="tooltip-container"></span>val p2:Parser[Unit] = ???
</span><span id="5" class="hideable"><span class="tooltip-container"></span>val p3:Parser[A] = ???
</span><span id="6" class="hideable"><span class="tooltip-container"></span>
</span><span id="8" class=""><span class="tooltip-container"></span>((p1:Parser[Unit]) orElse (p2:Parser[Unit])):Parser[Unit]
</span><span id="9" class=""><span class="tooltip-container"></span>((p3:Parser[A]   ) orElse (p2:Parser[Unit])):Parser[Option[A]]
</span></code></pre>
   </div> 
   <p>This library provides a non-given instance of Eithered, named <code>discriminatedUnion</code>, that instead places the two values in a <code>scala.Either</code>.</p> 
   <div class="snippet" scala-snippet="" runnable="">
    <div class="buttons"></div>
    <pre><code class="language-scala"><span id="1" class="hideable"><span class="tooltip-container"></span>import com.rayrobdod.stringContextParserCombinator.Parsers._
</span><span id="2" class="hideable"><span class="tooltip-container"></span>import com.rayrobdod.stringContextParserCombinator.typelevel.Eithered
</span><span id="3" class="hideable"><span class="tooltip-container"></span>class A {}
</span><span id="4" class="hideable"><span class="tooltip-container"></span>class B {}
</span><span id="5" class="hideable"><span class="tooltip-container"></span>val p1:Parser[A] = ???
</span><span id="6" class="hideable"><span class="tooltip-container"></span>val p2:Parser[B] = ???
</span><span id="7" class="hideable"><span class="tooltip-container"></span>
</span><span id="9" class=""><span class="tooltip-container"></span>val discriminated:Parser[Either[A, B]] = (p1:Parser[A]).orElse(p2:Parser[B])(using Eithered.discriminatedUnion)
</span><span id="10" class=""><span class="tooltip-container"></span>// in the following, even digits are placed in a Left while odd digits are placed in a Right.
</span><span id="11" class=""><span class="tooltip-container"></span>val evenOdd:Parser[Either[Char, Char]] = CharIn("02468").orElse(CharIn("13579"))(using Eithered.discriminatedUnion)
</span></code></pre>
   </div> 
   <p>The interface consists of two methods, the <code>left</code> method called if the first choice succeeded, or <code>right</code> if the second choice succeeded.</p> 
   <p>Below is example of defining and using a custom Eithered.</p> 
   <div class="snippet" scala-snippet="" runnable="">
    <div class="buttons"></div>
    <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>import java.io.File
</span><span id="1" class=""><span class="tooltip-container"></span>import java.net.URI
</span><span id="2" class=""><span class="tooltip-container"></span>import java.util.UUID
</span><span id="4" class="hideable"><span class="tooltip-container"></span>import com.rayrobdod.stringContextParserCombinator.Parsers._
</span><span id="5" class="hideable"><span class="tooltip-container"></span>import com.rayrobdod.stringContextParserCombinator.typelevel.Eithered
</span><span id="6" class="hideable"><span class="tooltip-container"></span>val uuidParser:Parser[UUID] = ???
</span><span id="7" class="hideable"><span class="tooltip-container"></span>val fileParser:Parser[File] = ???
</span><span id="8" class="hideable"><span class="tooltip-container"></span>
</span><span id="10" class=""><span class="tooltip-container"></span>given Eithered[File, UUID, URI] with {
</span><span id="11" class=""><span class="tooltip-container"></span>	def left(f:File):URI = f.toURI
</span><span id="12" class=""><span class="tooltip-container"></span>	def right(id:UUID):URI = new URI("urn", s"uuid:${id}", null)
</span><span id="13" class=""><span class="tooltip-container"></span>}
</span><span id="14" class=""><span class="tooltip-container"></span>
</span><span id="15" class=""><span class="tooltip-container"></span>((fileParser:Parser[File]) orElse (uuidParser:Parser[UUID])):Parser[URI]
</span></code></pre>
   </div>
  </section>
  <section id="repeated"> 
   <h1><a href="#repeated" class="anchor"></a>Repeated</h1> 
   <p>A <a href="../com/rayrobdod/stringContextParserCombinator/typelevel/Repeated.html">Repeated</a> describes how to combine a homogeneous sequence of zero-or-more values.</p> 
   <p>The fallback given Repeated places the items in a <code>scala.Seq</code>.</p> 
   <div class="snippet" scala-snippet="" runnable="">
    <div class="buttons"></div>
    <pre><code class="language-scala"><span id="1" class="hideable"><span class="tooltip-container"></span>import com.rayrobdod.stringContextParserCombinator.Parsers.Parser
</span><span id="2" class="hideable"><span class="tooltip-container"></span>class A {}
</span><span id="3" class="hideable"><span class="tooltip-container"></span>val p1:Parser[A] = ???
</span><span id="4" class="hideable"><span class="tooltip-container"></span>
</span><span id="6" class=""><span class="tooltip-container"></span>((p1:Parser[A]).repeat()):Parser[List[A]]
</span></code></pre>
   </div> 
   <p>A given Repeated is provided which combines repeated <code>scala.Unit</code> values into a single <code>scala.Unit</code></p> 
   <p>A given Repeated is provided which combines repeated <code>scala.Char</code> values into a <code>String</code>, and another that combines repeated <code>CodePoint</code> values into a <code>String</code>.</p> 
   <div class="snippet" scala-snippet="" runnable="">
    <div class="buttons"></div>
    <pre><code class="language-scala"><span id="1" class="hideable"><span class="tooltip-container"></span>import com.rayrobdod.stringContextParserCombinator.CodePoint
</span><span id="2" class="hideable"><span class="tooltip-container"></span>import com.rayrobdod.stringContextParserCombinator.Parsers.Parser
</span><span id="3" class="hideable"><span class="tooltip-container"></span>val unitParser:Parser[Unit] = ???
</span><span id="4" class="hideable"><span class="tooltip-container"></span>val charParser:Parser[Char] = ???
</span><span id="5" class="hideable"><span class="tooltip-container"></span>val codePointParser:Parser[CodePoint] = ???
</span><span id="6" class="hideable"><span class="tooltip-container"></span>
</span><span id="8" class=""><span class="tooltip-container"></span>(unitParser:Parser[Unit]).repeat():Parser[Unit]
</span><span id="9" class=""><span class="tooltip-container"></span>(charParser:Parser[Char]).repeat():Parser[String]
</span><span id="10" class=""><span class="tooltip-container"></span>(codePointParser:Parser[CodePoint]).repeat():Parser[String]
</span></code></pre>
   </div> 
   <p>When a Repeated is used</p> 
   <ul> 
    <li>first, <code>init</code> is called to create a new mutable builder</li> 
    <li>then, <code>append</code> is called once for each component item in order, using the <code>init</code>-created builder and the component item as parameters</li> 
    <li>lastly, <code>result</code> is called with the builder, and the result of this call is overall result.</li> 
   </ul> 
   <p>Below is example of providing and using custom Repeated.</p> 
   <div class="snippet" scala-snippet="" runnable="">
    <div class="buttons"></div>
    <pre><code class="language-scala"><span id="1" class="hideable"><span class="tooltip-container"></span>import com.rayrobdod.stringContextParserCombinator.Parsers._
</span><span id="2" class="hideable"><span class="tooltip-container"></span>import com.rayrobdod.stringContextParserCombinator.typelevel.Repeated
</span><span id="3" class="hideable"><span class="tooltip-container"></span>
</span><span id="5" class=""><span class="tooltip-container"></span>// define the marker types
</span><span id="6" class=""><span class="tooltip-container"></span>/** represents a single digit */
</span><span id="7" class=""><span class="tooltip-container"></span>case class Digit(value:Int)
</span><span id="8" class=""><span class="tooltip-container"></span>/** represents a sequence of digits */
</span><span id="9" class=""><span class="tooltip-container"></span>case class Digits(value:Int)
</span><span id="10" class=""><span class="tooltip-container"></span>
</span><span id="11" class=""><span class="tooltip-container"></span>// define the given instance
</span><span id="12" class=""><span class="tooltip-container"></span>given Repeated[Digit, Digits] with {
</span><span id="13" class=""><span class="tooltip-container"></span>	final class Box(var value:Int)
</span><span id="14" class=""><span class="tooltip-container"></span>	type Acc = Box
</span><span id="15" class=""><span class="tooltip-container"></span>	def init():Acc = new Box(0)
</span><span id="16" class=""><span class="tooltip-container"></span>	def append(acc:Acc, elem:Digit):Unit = {acc.value *= 10; acc.value += elem.value}
</span><span id="17" class=""><span class="tooltip-container"></span>	def result(acc:Acc):Digits = new Digits(acc.value)
</span><span id="18" class=""><span class="tooltip-container"></span>}
</span><span id="19" class=""><span class="tooltip-container"></span>
</span><span id="20" class=""><span class="tooltip-container"></span>// create the parsers
</span><span id="21" class=""><span class="tooltip-container"></span>val digit:Parser[Digit] = CharIn('0' to '9').map(x =&gt; Digit(x - '0'))
</span><span id="22" class=""><span class="tooltip-container"></span>val digits:Parser[Digits] = digit.repeat(1)
</span></code></pre>
   </div>
  </section>
  <section id="optionally"> 
   <h1><a href="#optionally" class="anchor"></a>Optionally</h1> 
   <p>An <a href="../com/rayrobdod/stringContextParserCombinator/typelevel/Optionally.html">Optionally</a> describes the result of a parser that might parse another value.</p> 
   <p>The fallback given Optionally places the items in a <code>scala.Option</code>, wrapping a found value in a Some and using a None as the empty value.</p> 
   <div class="snippet" scala-snippet="" runnable="">
    <div class="buttons"></div>
    <pre><code class="language-scala"><span id="1" class="hideable"><span class="tooltip-container"></span>import com.rayrobdod.stringContextParserCombinator.Parsers.Parser
</span><span id="2" class="hideable"><span class="tooltip-container"></span>class A {}
</span><span id="3" class="hideable"><span class="tooltip-container"></span>val p1:Parser[A] = ???
</span><span id="4" class="hideable"><span class="tooltip-container"></span>
</span><span id="6" class=""><span class="tooltip-container"></span>((p1:Parser[A]).optionally()):Parser[Option[A]]
</span></code></pre>
   </div> 
   <p>The <code>Unit</code>-handling Optionally value doesn't wrap a present <code>()</code> in an Option, and uses <code>()</code> as a default value.</p> 
   <div class="snippet" scala-snippet="" runnable="">
    <div class="buttons"></div>
    <pre><code class="language-scala"><span id="1" class="hideable"><span class="tooltip-container"></span>import com.rayrobdod.stringContextParserCombinator.Parsers.Parser
</span><span id="2" class="hideable"><span class="tooltip-container"></span>val p1:Parser[Unit] = ???
</span><span id="3" class="hideable"><span class="tooltip-container"></span>
</span><span id="5" class=""><span class="tooltip-container"></span>((p1:Parser[Unit]).optionally()):Parser[Option[Unit]]
</span></code></pre>
   </div> 
   <p>The interface consists of two methods, the <code>some</code> method called if there was a value, and <code>none</code> method called if there was no value.</p> 
   <p>Below is example of defining and using a custom Optionally. This Optionally has the effect of using the empty string as a default value.</p> 
   <div class="snippet" scala-snippet="" runnable="">
    <div class="buttons"></div>
    <pre><code class="language-scala"><span id="1" class="hideable"><span class="tooltip-container"></span>import com.rayrobdod.stringContextParserCombinator.Parsers._
</span><span id="2" class="hideable"><span class="tooltip-container"></span>import com.rayrobdod.stringContextParserCombinator.typelevel.Optionally
</span><span id="3" class="hideable"><span class="tooltip-container"></span>val stringParser:Parser[String] = ???
</span><span id="4" class="hideable"><span class="tooltip-container"></span>
</span><span id="6" class=""><span class="tooltip-container"></span>given Optionally[String, String] with {
</span><span id="7" class=""><span class="tooltip-container"></span>	def none:String = ""
</span><span id="8" class=""><span class="tooltip-container"></span>	def some(s:String):String = s
</span><span id="9" class=""><span class="tooltip-container"></span>}
</span><span id="10" class=""><span class="tooltip-container"></span>
</span><span id="11" class=""><span class="tooltip-container"></span>((stringParser:Parser[String]).optionally()):Parser[String]
</span></code></pre>
   </div>
  </section> 
 </body>
</html></div></main><footer><div id="generated-by"><span class="footer-text">Generated by</span><a href="https://github.com/lampepfl/dotty/tree/main/scaladoc"><img src="../images/scaladoc_logo.svg" alt="scaladoc" class="scaladoc_logo"></img><img src="../images/scaladoc_logo_dark.svg" alt="scaladoc" class="scaladoc_logo_dark"></img></a></div><div class="socials"><span class="footer-text">Social links</span><a href="https://github.com/rayrobdod/string-context-parser-combinator"><span class="social-icon" data-icon-path="github-icon-black.png"></span></a></div><div class="mode"><span class="footer-text">Mode</span><label id="theme-toggle" class="switch"><input type="checkbox"></input><span class="slider"></span></label></div><span class="go-to-top-icon"><a href="#container"><span class="icon-vertical_align_top"></span><span class="footer-text">Back to top</span></a></span></footer></div><div id="toc"><span class="toc-title">In this article</span><nav class="toc-nav"><ul class="toc-list"><li><a href="#sequenced">Sequenced</a></li></ul></nav></div></div></body></html>